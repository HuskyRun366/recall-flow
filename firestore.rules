rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isQuizOwner(quizId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/quizzes/$(quizId)).data.ownerId == request.auth.uid;
    }

    function isCoAuthor(quizId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid)).data.role == 'co-author';
    }

    function canEditQuiz(quizId) {
      return isQuizOwner(quizId) || isCoAuthor(quizId);
    }

    function canAccessQuiz(quizId) {
      let quiz = get(/databases/$(database)/documents/quizzes/$(quizId)).data;
      return quiz.visibility == 'public' ||
             quiz.visibility == 'unlisted' ||
             isQuizOwner(quizId) ||
             exists(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid));
    }

    function isQuizParticipant(quizId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid));
    }

    function isValidQuizParticipantCountUpdate(quizId) {
      return isQuizParticipant(quizId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        request.resource.data.metadata.diff(resource.data.metadata).changedKeys().hasOnly(['totalParticipants']) &&
        request.resource.data.metadata.totalParticipants is int &&
        request.resource.data.metadata.totalParticipants >= 0 &&
        (
          request.resource.data.metadata.totalParticipants == resource.data.metadata.totalParticipants + 1 ||
          request.resource.data.metadata.totalParticipants == resource.data.metadata.totalParticipants - 1
        );
    }

    function isValidQuizRatingUpdate(quizId) {
      return isAuthenticated() &&
        canAccessQuiz(quizId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['averageRating', 'ratingCount', 'updatedAt']) &&
        request.resource.data.averageRating is number &&
        request.resource.data.averageRating >= 0 &&
        request.resource.data.averageRating <= 5 &&
        request.resource.data.ratingCount is int &&
        request.resource.data.ratingCount >= 0 &&
        request.resource.data.updatedAt is timestamp;
    }

    // Users collection
    match /users/{userId} {
      allow read: if isAuthenticated();  // Allow reading user profiles for co-author lookup
      allow create: if isOwner(userId);
      // Allow update by owner, or allow follower/following count updates by authenticated users
      allow update: if isOwner(userId) || (
        isAuthenticated() &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['followerCount']) &&
        request.resource.data.followerCount is int &&
        request.resource.data.followerCount >= 0
      ) || (
        isAuthenticated() &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['followingCount']) &&
        request.resource.data.followingCount is int &&
        request.resource.data.followingCount >= 0
      );
      allow delete: if isOwner(userId);

      // User's quiz references
      match /userQuizzes/{quizId} {
        allow read: if isOwner(userId);
        allow create: if (isOwner(userId) &&
          get(/databases/$(database)/documents/quizzes/$(quizId)).data.visibility in ['public', 'unlisted']
        ) || canEditQuiz(quizId); // Or if quiz owner/co-author is inviting them
        allow update: if isOwner(userId) || canEditQuiz(quizId); // Allow quiz owner/co-author to update role
        allow delete: if isOwner(userId) || canEditQuiz(quizId); // Allow quiz owner/co-author to remove participant
      }

      // Following subcollection - who the user follows
      match /following/{followedUserId} {
        allow read: if isAuthenticated();
        allow create: if isOwner(userId) && request.resource.data.followedUserId == followedUserId;
        allow delete: if isOwner(userId) ||
          (isAuthenticated() && resource.data.followedUserId == request.auth.uid);
      }

      // Followers subcollection - who follows the user
      match /followers/{followerId} {
        allow read: if isAuthenticated();
        allow create: if isOwner(followerId); // Only the follower can add themselves
        allow delete: if isOwner(followerId) || isOwner(userId); // Follower or profile owner can remove
      }

      // FCM tokens for push notifications
      match /fcmTokens/{token} {
        allow read, create, update, delete: if request.auth != null && request.auth.uid == userId;
      }

      // User folders for organizing content
      match /folders/{folderId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
    }

    // Email lookup collection
    match /usersByEmail/{emailDocId} {
      allow read: if isAuthenticated();
      // Allow users to create their own email lookup entry
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      // Prevent modification and deletion for data integrity
      allow update: if false;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // User notifications (badge/read tracking)
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if false;
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Follow notifications (new quiz from followed authors)
    match /followNotifications/{notificationId} {
      // Only the notification recipient can read their notifications
      allow read: if isAuthenticated() &&
        (resource.data.userId == request.auth.uid || resource.data.authorId == request.auth.uid);
      // Any authenticated user can create notifications (for followers)
      allow create: if isAuthenticated();
      // Only the recipient can mark as read
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.diff(resource.data).changedKeys().hasOnly(['read']);
      // Recipient or author can delete (needed for account deletion)
      allow delete: if isAuthenticated() &&
        (resource.data.userId == request.auth.uid || resource.data.authorId == request.auth.uid);
    }

    // Quizzes collection
    match /quizzes/{quizId} {
      // Allow reading if:
      // 1. Quiz is public or unlisted (anyone can read)
      // 2. User is the owner
      // 3. User is a participant (checked via quizParticipants collection)
      allow read: if resource.data.visibility in ['public', 'unlisted'] ||
                     (isAuthenticated() && resource.data.ownerId == request.auth.uid) ||
                     (isAuthenticated() && exists(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid)));
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
      allow update: if canEditQuiz(quizId) ||
        isValidQuizParticipantCountUpdate(quizId) ||
        isValidQuizRatingUpdate(quizId);
      allow delete: if isQuizOwner(quizId);
    }

    // Questions collection
    match /questions/{questionId} {
      allow read: if isAuthenticated() && canAccessQuiz(resource.data.quizId);
      allow create: if isAuthenticated() && canEditQuiz(request.resource.data.quizId);
      allow update: if isAuthenticated() && canEditQuiz(resource.data.quizId);
      allow delete: if isAuthenticated() && canEditQuiz(resource.data.quizId);
    }

    // Quiz participants
    match /quizParticipants/{quizId}/participants/{userId} {
      allow read: if canAccessQuiz(quizId);
      allow create: if canEditQuiz(quizId) || (
        isAuthenticated() &&
        request.auth.uid == userId &&
        (
          get(/databases/$(database)/documents/quizzes/$(quizId)).data.visibility == 'public' ||
          get(/databases/$(database)/documents/quizzes/$(quizId)).data.visibility == 'unlisted'
        ) &&
        request.resource.data.role == 'participant' &&
        request.resource.data.status == 'accepted'
      );
      allow update: if canEditQuiz(quizId) || (isOwner(userId) && request.resource.data.status == 'accepted');
      allow delete: if canEditQuiz(quizId) || isOwner(userId);
    }

    // Quiz progress
    match /quizProgress/{quizId}/userProgress/{userId} {
      allow read: if isOwner(userId) || canEditQuiz(quizId);
      allow create, update: if isOwner(userId) && canAccessQuiz(quizId);
      allow delete: if isOwner(userId);

      // Question progress subcollection
      match /questionProgress/{questionId} {
        allow read: if isOwner(userId) || canEditQuiz(quizId);
        allow create, update: if isOwner(userId) && canAccessQuiz(quizId);
        allow delete: if isOwner(userId);
      }
    }

    // Quiz analytics (aggregated stats)
    match /quizAnalytics/{quizId} {
      allow read: if canEditQuiz(quizId);
      allow write: if false;

      match /questionStats/{questionId} {
        allow read: if canEditQuiz(quizId);
        allow create, update: if isAuthenticated() && canAccessQuiz(quizId);
        allow delete: if canEditQuiz(quizId);
      }
    }

    // =============================================
    // FLASHCARD DECK RULES (separate from quizzes)
    // =============================================

    // Helper functions for decks
    function isDeckOwner(deckId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data.ownerId == request.auth.uid;
    }

    function isCoAuthorDeck(deckId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid)).data.role == 'co-author';
    }

    function canEditDeck(deckId) {
      return isDeckOwner(deckId) || isCoAuthorDeck(deckId);
    }

    function canAccessDeck(deckId) {
      let deck = get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data;
      return deck.visibility in ['public', 'unlisted'] ||
             isDeckOwner(deckId) ||
             exists(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid));
    }

    function isDeckParticipant(deckId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid));
    }

    function isValidDeckStudentCountUpdate(deckId) {
      return isDeckParticipant(deckId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        request.resource.data.metadata.diff(resource.data.metadata).changedKeys().hasOnly(['totalStudents']) &&
        request.resource.data.metadata.totalStudents is int &&
        request.resource.data.metadata.totalStudents >= 0 &&
        (
          request.resource.data.metadata.totalStudents == resource.data.metadata.totalStudents + 1 ||
          request.resource.data.metadata.totalStudents == resource.data.metadata.totalStudents - 1
        );
    }

    function isValidDeckRatingUpdate(deckId) {
      return isAuthenticated() &&
        canAccessDeck(deckId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['averageRating', 'ratingCount', 'updatedAt']) &&
        request.resource.data.averageRating is number &&
        request.resource.data.averageRating >= 0 &&
        request.resource.data.averageRating <= 5 &&
        request.resource.data.ratingCount is int &&
        request.resource.data.ratingCount >= 0 &&
        request.resource.data.updatedAt is timestamp;
    }

    // User's deck references (denormalized for user queries)
    match /users/{userId}/userDecks/{deckId} {
      allow read: if isOwner(userId);
      allow create: if (isOwner(userId) &&
        get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data.visibility in ['public', 'unlisted']
      ) || canEditDeck(deckId);
      allow update: if isOwner(userId) || canEditDeck(deckId);
      allow delete: if isOwner(userId) || canEditDeck(deckId);
    }

    // Flashcard Decks collection
    match /flashcardDecks/{deckId} {
      allow read: if resource.data.visibility in ['public', 'unlisted'] ||
                     (isAuthenticated() && resource.data.ownerId == request.auth.uid) ||
                     (isAuthenticated() && exists(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid)));
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
      allow update: if canEditDeck(deckId) ||
        isValidDeckStudentCountUpdate(deckId) ||
        isValidDeckRatingUpdate(deckId);
      allow delete: if isDeckOwner(deckId);
    }

    // Flashcards collection
    match /flashcards/{cardId} {
      allow read: if isAuthenticated() && canAccessDeck(resource.data.deckId);
      allow create: if isAuthenticated() && canEditDeck(request.resource.data.deckId);
      allow update: if isAuthenticated() && canEditDeck(resource.data.deckId);
      allow delete: if isAuthenticated() && canEditDeck(resource.data.deckId);
    }

    // Deck participants
    match /deckParticipants/{deckId}/participants/{userId} {
      allow read: if canAccessDeck(deckId);
      allow create: if canEditDeck(deckId) || (
        isAuthenticated() &&
        request.auth.uid == userId &&
        (
          get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data.visibility == 'public' ||
          get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data.visibility == 'unlisted'
        ) &&
        request.resource.data.role == 'student' &&
        request.resource.data.status == 'accepted'
      );
      allow update: if canEditDeck(deckId) || (isOwner(userId) && request.resource.data.status == 'accepted');
      allow delete: if canEditDeck(deckId) || isOwner(userId);
    }

    // Flashcard progress
    match /flashcardProgress/{deckId}/userProgress/{userId} {
      allow read: if isOwner(userId) || canEditDeck(deckId);
      allow create, update: if isOwner(userId) && canAccessDeck(deckId);
      allow delete: if isOwner(userId);

      // Card progress subcollection
      match /cardProgress/{cardId} {
        allow read: if isOwner(userId) || canEditDeck(deckId);
        allow create, update: if isOwner(userId) && canAccessDeck(deckId);
        allow delete: if isOwner(userId);
      }
    }

    // =============================================
    // LEARNING MATERIALS RULES
    // =============================================

    // Helper functions for learning materials
    function isMaterialOwner(materialId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/learningMaterials/$(materialId)).data.ownerId == request.auth.uid;
    }

    function isCoAuthorMaterial(materialId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid)).data.role == 'co-author';
    }

    function canEditMaterial(materialId) {
      return isMaterialOwner(materialId) || isCoAuthorMaterial(materialId);
    }

    function canAccessMaterial(materialId) {
      let material = get(/databases/$(database)/documents/learningMaterials/$(materialId)).data;
      return material.visibility in ['public', 'unlisted'] ||
             isMaterialOwner(materialId) ||
             exists(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid));
    }

    function isMaterialParticipant(materialId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid));
    }

    function isValidMaterialStudentCountUpdate(materialId) {
      return isMaterialParticipant(materialId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        request.resource.data.metadata.diff(resource.data.metadata).changedKeys().hasOnly(['totalStudents']) &&
        request.resource.data.metadata.totalStudents is int &&
        request.resource.data.metadata.totalStudents >= 0 &&
        (
          request.resource.data.metadata.totalStudents == resource.data.metadata.totalStudents + 1 ||
          request.resource.data.metadata.totalStudents == resource.data.metadata.totalStudents - 1
        );
    }

    function isValidMaterialRatingUpdate(materialId) {
      return isAuthenticated() &&
        canAccessMaterial(materialId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['averageRating', 'ratingCount', 'updatedAt']) &&
        request.resource.data.averageRating is number &&
        request.resource.data.averageRating >= 0 &&
        request.resource.data.averageRating <= 5 &&
        request.resource.data.ratingCount is int &&
        request.resource.data.ratingCount >= 0 &&
        request.resource.data.updatedAt is timestamp;
    }

    // User's material references (denormalized for user queries)
    match /users/{userId}/userMaterials/{materialId} {
      allow read: if isOwner(userId);
      allow create: if (isOwner(userId) &&
        get(/databases/$(database)/documents/learningMaterials/$(materialId)).data.visibility in ['public', 'unlisted']
      ) || canEditMaterial(materialId);
      allow update: if isOwner(userId) || canEditMaterial(materialId);
      allow delete: if isOwner(userId) || canEditMaterial(materialId);
    }

    // Learning Materials collection
    match /learningMaterials/{materialId} {
      allow read: if resource.data.visibility in ['public', 'unlisted'] ||
                     (isAuthenticated() && resource.data.ownerId == request.auth.uid) ||
                     (isAuthenticated() && exists(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid)));
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
      allow update: if canEditMaterial(materialId) ||
        isValidMaterialStudentCountUpdate(materialId) ||
        isValidMaterialRatingUpdate(materialId);
      allow delete: if isMaterialOwner(materialId);
    }

    // Material participants
    match /materialParticipants/{materialId}/participants/{userId} {
      allow read: if canAccessMaterial(materialId);
      allow create: if canEditMaterial(materialId) || (
        isAuthenticated() &&
        request.auth.uid == userId &&
        (
          get(/databases/$(database)/documents/learningMaterials/$(materialId)).data.visibility == 'public' ||
          get(/databases/$(database)/documents/learningMaterials/$(materialId)).data.visibility == 'unlisted'
        ) &&
        request.resource.data.role == 'student' &&
        request.resource.data.status == 'accepted'
      );
      allow update: if canEditMaterial(materialId) || (isOwner(userId) && request.resource.data.status == 'accepted');
      allow delete: if canEditMaterial(materialId) || isOwner(userId);
    }

    // =============================================
    // THEMES RULES
    // =============================================

    function isValidThemeInstallUpdate() {
      return isAuthenticated() &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        request.resource.data.metadata.diff(resource.data.metadata).changedKeys().hasOnly(['totalInstalls']) &&
        request.resource.data.metadata.totalInstalls is int &&
        request.resource.data.metadata.totalInstalls >= 0 &&
        (
          request.resource.data.metadata.totalInstalls == resource.data.metadata.totalInstalls + 1 ||
          request.resource.data.metadata.totalInstalls == resource.data.metadata.totalInstalls - 1
        );
    }

    function isValidThemeRatingUpdate() {
      return isAuthenticated() &&
        resource.data.visibility == 'public' &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['averageRating', 'ratingCount', 'updatedAt']) &&
        request.resource.data.averageRating is number &&
        request.resource.data.averageRating >= 0 &&
        request.resource.data.averageRating <= 5 &&
        request.resource.data.ratingCount is int &&
        request.resource.data.ratingCount >= 0 &&
        request.resource.data.updatedAt is timestamp;
    }

    match /themes/{themeId} {
      allow read: if resource.data.visibility == 'public' || isOwner(resource.data.ownerId);

      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.visibility in ['public', 'private'];

      allow update: if (
        isAuthenticated() &&
        resource.data.ownerId == request.auth.uid &&
        request.resource.data.ownerId == request.auth.uid &&
        request.resource.data.visibility in ['public', 'private']
      ) || isValidThemeInstallUpdate() || isValidThemeRatingUpdate();

      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
    }

    // =============================================
    // REVIEWS RULES (for marketplace)
    // =============================================

    // Helper function to check if user can access content for review
    function canAccessContent(contentType, contentId) {
      return contentType == 'quiz' ? (
        get(/databases/$(database)/documents/quizzes/$(contentId)).data.visibility in ['public', 'unlisted']
      ) : contentType == 'deck' ? (
        get(/databases/$(database)/documents/flashcardDecks/$(contentId)).data.visibility in ['public', 'unlisted']
      ) : contentType == 'material' ? (
        get(/databases/$(database)/documents/learningMaterials/$(contentId)).data.visibility in ['public', 'unlisted']
      ) : contentType == 'theme' ? (
        get(/databases/$(database)/documents/themes/$(contentId)).data.visibility == 'public'
      ) : false;
    }

    // Helper function to check if user is content owner
    function isContentOwner(contentType, contentId) {
      return contentType == 'quiz' ? (
        get(/databases/$(database)/documents/quizzes/$(contentId)).data.ownerId == request.auth.uid
      ) : contentType == 'deck' ? (
        get(/databases/$(database)/documents/flashcardDecks/$(contentId)).data.ownerId == request.auth.uid
      ) : contentType == 'material' ? (
        get(/databases/$(database)/documents/learningMaterials/$(contentId)).data.ownerId == request.auth.uid
      ) : contentType == 'theme' ? (
        get(/databases/$(database)/documents/themes/$(contentId)).data.ownerId == request.auth.uid
      ) : false;
    }

    // Helper function to check if user is enrolled (participant) - without checking ownership
    function isParticipant(contentType, contentId) {
      return contentType == 'quiz' ?
        exists(/databases/$(database)/documents/quizParticipants/$(contentId)/participants/$(request.auth.uid))
      : contentType == 'deck' ?
        exists(/databases/$(database)/documents/deckParticipants/$(contentId)/participants/$(request.auth.uid))
      : contentType == 'material' ?
        exists(/databases/$(database)/documents/materialParticipants/$(contentId)/participants/$(request.auth.uid))
      : contentType == 'theme' ?
        true  // For themes, allow all authenticated users (can't check localStorage)
      : false;
    }

    // Reviews collection
    match /reviews/{reviewId} {
      // Anyone can read reviews for public/unlisted content
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        canAccessContent(resource.data.contentType, resource.data.contentId)
      );

      // Authenticated users can create reviews ONLY if:
      // 1. User is a participant (enrolled in content) OR content owner
      // 2. Rating is valid (1-5)
      // 3. User ID matches authenticated user
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       (isParticipant(request.resource.data.contentType, request.resource.data.contentId) ||
                        isContentOwner(request.resource.data.contentType, request.resource.data.contentId)) &&
                       request.resource.data.rating >= 1 &&
                       request.resource.data.rating <= 5;

      // Only review author can update their own review
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.rating >= 1 &&
                       request.resource.data.rating <= 5;

      // Review author or content owner can delete reviews
      allow delete: if isAuthenticated() &&
                       (resource.data.userId == request.auth.uid ||
                        isContentOwner(resource.data.contentType, resource.data.contentId));
    }

    // =============================================
    // CONFIG COLLECTION (for featured content, etc.)
    // =============================================

    // Config collection for app-wide settings (read-only for users)
    match /config/{configId} {
      allow read: if true;  // Anyone can read config (including featuredContent)
      allow write: if false;  // Only admin SDK can write (server-side)
    }

    // =============================================
    // TRENDING & RECOMMENDATIONS (server-calculated)
    // =============================================

    // Trending quizzes (calculated by notification server)
    match /trending/{quizId} {
      allow read: if true;  // Anyone can read trending (public data)
      allow write: if false;  // Only admin SDK can write (server-side)
    }

    // User recommendations (stored per user by notification server)
    match /users/{userId}/recommendations/{quizId} {
      allow read: if isOwner(userId);  // Only owner can read their recommendations
      allow write: if false;  // Only admin SDK can write (server-side)
    }

    // System stats (cleanup, storage, trending stats)
    match /system/{docId} {
      allow read: if isAuthenticated();  // Authenticated users can read system stats
      allow write: if false;  // Only admin SDK can write (server-side)
    }
  }
}
