rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isQuizOwner(quizId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/quizzes/$(quizId)).data.ownerId == request.auth.uid;
    }

    function isCoAuthor(quizId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid)).data.role == 'co-author';
    }

    function canEditQuiz(quizId) {
      return isQuizOwner(quizId) || isCoAuthor(quizId);
    }

    function canAccessQuiz(quizId) {
      let quiz = get(/databases/$(database)/documents/quizzes/$(quizId)).data;
      return quiz.visibility == 'public' ||
             quiz.visibility == 'unlisted' ||
             isQuizOwner(quizId) ||
             exists(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid));
    }

    function isQuizParticipant(quizId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid));
    }

    function isValidQuizParticipantCountUpdate(quizId) {
      return isQuizParticipant(quizId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        request.resource.data.metadata.diff(resource.data.metadata).changedKeys().hasOnly(['totalParticipants']) &&
        request.resource.data.metadata.totalParticipants is int &&
        request.resource.data.metadata.totalParticipants >= 0 &&
        (
          request.resource.data.metadata.totalParticipants == resource.data.metadata.totalParticipants + 1 ||
          request.resource.data.metadata.totalParticipants == resource.data.metadata.totalParticipants - 1
        );
    }

    // Users collection
    match /users/{userId} {
      allow read: if isAuthenticated();  // Allow reading user profiles for co-author lookup
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);

      // User's quiz references
      match /userQuizzes/{quizId} {
        allow read: if isOwner(userId);
        allow create: if (isOwner(userId) &&
          get(/databases/$(database)/documents/quizzes/$(quizId)).data.visibility in ['public', 'unlisted']
        ) || canEditQuiz(quizId); // Or if quiz owner/co-author is inviting them
        allow update: if isOwner(userId) || canEditQuiz(quizId); // Allow quiz owner/co-author to update role
        allow delete: if isOwner(userId) || canEditQuiz(quizId); // Allow quiz owner/co-author to remove participant
      }

      // FCM tokens for push notifications
      match /fcmTokens/{token} {
        allow create, delete: if request.auth != null && request.auth.uid == userId;
        allow read: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Email lookup collection
    match /usersByEmail/{emailDocId} {
      allow read: if isAuthenticated();
      // Allow users to create their own email lookup entry
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      // Prevent modification and deletion for data integrity
      allow update, delete: if false;
    }

    // Quizzes collection
    match /quizzes/{quizId} {
      // Allow reading if:
      // 1. Quiz is public or unlisted (anyone can read)
      // 2. User is the owner
      // 3. User is a participant (checked via quizParticipants collection)
      allow read: if resource.data.visibility in ['public', 'unlisted'] ||
                     (isAuthenticated() && resource.data.ownerId == request.auth.uid) ||
                     (isAuthenticated() && exists(/databases/$(database)/documents/quizParticipants/$(quizId)/participants/$(request.auth.uid)));
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
      allow update: if canEditQuiz(quizId) || isValidQuizParticipantCountUpdate(quizId);
      allow delete: if isQuizOwner(quizId);
    }

    // Questions collection
    match /questions/{questionId} {
      allow read: if isAuthenticated() && canAccessQuiz(resource.data.quizId);
      allow create: if isAuthenticated() && canEditQuiz(request.resource.data.quizId);
      allow update: if isAuthenticated() && canEditQuiz(resource.data.quizId);
      allow delete: if isAuthenticated() && canEditQuiz(resource.data.quizId);
    }

    // Quiz participants
    match /quizParticipants/{quizId}/participants/{userId} {
      allow read: if canAccessQuiz(quizId);
      allow create: if canEditQuiz(quizId) || (
        isAuthenticated() &&
        request.auth.uid == userId &&
        (
          get(/databases/$(database)/documents/quizzes/$(quizId)).data.visibility == 'public' ||
          get(/databases/$(database)/documents/quizzes/$(quizId)).data.visibility == 'unlisted'
        ) &&
        request.resource.data.role == 'participant' &&
        request.resource.data.status == 'accepted'
      );
      allow update: if canEditQuiz(quizId) || (isOwner(userId) && request.resource.data.status == 'accepted');
      allow delete: if canEditQuiz(quizId) || isOwner(userId);
    }

    // Quiz progress
    match /quizProgress/{quizId}/userProgress/{userId} {
      allow read: if isOwner(userId) || canEditQuiz(quizId);
      allow write: if isOwner(userId) && canAccessQuiz(quizId);

      // Question progress subcollection
      match /questionProgress/{questionId} {
        allow read: if isOwner(userId) || canEditQuiz(quizId);
        allow write: if isOwner(userId) && canAccessQuiz(quizId);
      }
    }

    // Quiz analytics (aggregated stats)
    match /quizAnalytics/{quizId} {
      allow read: if canEditQuiz(quizId);
      allow write: if false;

      match /questionStats/{questionId} {
        allow read: if canEditQuiz(quizId);
        allow create, update: if isAuthenticated() && canAccessQuiz(quizId);
        allow delete: if canEditQuiz(quizId);
      }
    }

    // =============================================
    // FLASHCARD DECK RULES (separate from quizzes)
    // =============================================

    // Helper functions for decks
    function isDeckOwner(deckId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data.ownerId == request.auth.uid;
    }

    function isCoAuthorDeck(deckId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid)).data.role == 'co-author';
    }

    function canEditDeck(deckId) {
      return isDeckOwner(deckId) || isCoAuthorDeck(deckId);
    }

    function canAccessDeck(deckId) {
      let deck = get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data;
      return deck.visibility in ['public', 'unlisted'] ||
             isDeckOwner(deckId) ||
             exists(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid));
    }

    function isDeckParticipant(deckId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid));
    }

    function isValidDeckStudentCountUpdate(deckId) {
      return isDeckParticipant(deckId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        request.resource.data.metadata.diff(resource.data.metadata).changedKeys().hasOnly(['totalStudents']) &&
        request.resource.data.metadata.totalStudents is int &&
        request.resource.data.metadata.totalStudents >= 0 &&
        (
          request.resource.data.metadata.totalStudents == resource.data.metadata.totalStudents + 1 ||
          request.resource.data.metadata.totalStudents == resource.data.metadata.totalStudents - 1
        );
    }

    // User's deck references (denormalized for user queries)
    match /users/{userId}/userDecks/{deckId} {
      allow read: if isOwner(userId);
      allow create: if (isOwner(userId) &&
        get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data.visibility in ['public', 'unlisted']
      ) || canEditDeck(deckId);
      allow update: if isOwner(userId) || canEditDeck(deckId);
      allow delete: if isOwner(userId) || canEditDeck(deckId);
    }

    // Flashcard Decks collection
    match /flashcardDecks/{deckId} {
      allow read: if resource.data.visibility in ['public', 'unlisted'] ||
                     (isAuthenticated() && resource.data.ownerId == request.auth.uid) ||
                     (isAuthenticated() && exists(/databases/$(database)/documents/deckParticipants/$(deckId)/participants/$(request.auth.uid)));
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
      allow update: if canEditDeck(deckId) || isValidDeckStudentCountUpdate(deckId);
      allow delete: if isDeckOwner(deckId);
    }

    // Flashcards collection
    match /flashcards/{cardId} {
      allow read: if isAuthenticated() && canAccessDeck(resource.data.deckId);
      allow create: if isAuthenticated() && canEditDeck(request.resource.data.deckId);
      allow update: if isAuthenticated() && canEditDeck(resource.data.deckId);
      allow delete: if isAuthenticated() && canEditDeck(resource.data.deckId);
    }

    // Deck participants
    match /deckParticipants/{deckId}/participants/{userId} {
      allow read: if canAccessDeck(deckId);
      allow create: if canEditDeck(deckId) || (
        isAuthenticated() &&
        request.auth.uid == userId &&
        (
          get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data.visibility == 'public' ||
          get(/databases/$(database)/documents/flashcardDecks/$(deckId)).data.visibility == 'unlisted'
        ) &&
        request.resource.data.role == 'student' &&
        request.resource.data.status == 'accepted'
      );
      allow update: if canEditDeck(deckId) || (isOwner(userId) && request.resource.data.status == 'accepted');
      allow delete: if canEditDeck(deckId) || isOwner(userId);
    }

    // Flashcard progress
    match /flashcardProgress/{deckId}/userProgress/{userId} {
      allow read: if isOwner(userId) || canEditDeck(deckId);
      allow write: if isOwner(userId) && canAccessDeck(deckId);

      // Card progress subcollection
      match /cardProgress/{cardId} {
        allow read: if isOwner(userId) || canEditDeck(deckId);
        allow write: if isOwner(userId) && canAccessDeck(deckId);
      }
    }

    // =============================================
    // LEARNING MATERIALS RULES
    // =============================================

    // Helper functions for learning materials
    function isMaterialOwner(materialId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/learningMaterials/$(materialId)).data.ownerId == request.auth.uid;
    }

    function isCoAuthorMaterial(materialId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid)).data.role == 'co-author';
    }

    function canEditMaterial(materialId) {
      return isMaterialOwner(materialId) || isCoAuthorMaterial(materialId);
    }

    function canAccessMaterial(materialId) {
      let material = get(/databases/$(database)/documents/learningMaterials/$(materialId)).data;
      return material.visibility in ['public', 'unlisted'] ||
             isMaterialOwner(materialId) ||
             exists(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid));
    }

    function isMaterialParticipant(materialId) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid));
    }

    function isValidMaterialStudentCountUpdate(materialId) {
      return isMaterialParticipant(materialId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        request.resource.data.metadata.diff(resource.data.metadata).changedKeys().hasOnly(['totalStudents']) &&
        request.resource.data.metadata.totalStudents is int &&
        request.resource.data.metadata.totalStudents >= 0 &&
        (
          request.resource.data.metadata.totalStudents == resource.data.metadata.totalStudents + 1 ||
          request.resource.data.metadata.totalStudents == resource.data.metadata.totalStudents - 1
        );
    }

    // User's material references (denormalized for user queries)
    match /users/{userId}/userMaterials/{materialId} {
      allow read: if isOwner(userId);
      allow create: if (isOwner(userId) &&
        get(/databases/$(database)/documents/learningMaterials/$(materialId)).data.visibility in ['public', 'unlisted']
      ) || canEditMaterial(materialId);
      allow update: if isOwner(userId) || canEditMaterial(materialId);
      allow delete: if isOwner(userId) || canEditMaterial(materialId);
    }

    // Learning Materials collection
    match /learningMaterials/{materialId} {
      allow read: if resource.data.visibility in ['public', 'unlisted'] ||
                     (isAuthenticated() && resource.data.ownerId == request.auth.uid) ||
                     (isAuthenticated() && exists(/databases/$(database)/documents/materialParticipants/$(materialId)/participants/$(request.auth.uid)));
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
      allow update: if canEditMaterial(materialId) || isValidMaterialStudentCountUpdate(materialId);
      allow delete: if isMaterialOwner(materialId);
    }

    // Material participants
    match /materialParticipants/{materialId}/participants/{userId} {
      allow read: if canAccessMaterial(materialId);
      allow create: if canEditMaterial(materialId) || (
        isAuthenticated() &&
        request.auth.uid == userId &&
        (
          get(/databases/$(database)/documents/learningMaterials/$(materialId)).data.visibility == 'public' ||
          get(/databases/$(database)/documents/learningMaterials/$(materialId)).data.visibility == 'unlisted'
        ) &&
        request.resource.data.role == 'student' &&
        request.resource.data.status == 'accepted'
      );
      allow update: if canEditMaterial(materialId) || (isOwner(userId) && request.resource.data.status == 'accepted');
      allow delete: if canEditMaterial(materialId) || isOwner(userId);
    }

    // =============================================
    // THEMES RULES
    // =============================================

    function isValidThemeInstallUpdate() {
      return isAuthenticated() &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        request.resource.data.metadata.diff(resource.data.metadata).changedKeys().hasOnly(['totalInstalls']) &&
        request.resource.data.metadata.totalInstalls is int &&
        request.resource.data.metadata.totalInstalls >= 0 &&
        (
          request.resource.data.metadata.totalInstalls == resource.data.metadata.totalInstalls + 1 ||
          request.resource.data.metadata.totalInstalls == resource.data.metadata.totalInstalls - 1
        );
    }

    match /themes/{themeId} {
      allow read: if resource.data.visibility == 'public' || isOwner(resource.data.ownerId);

      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.visibility in ['public', 'private'];

      allow update: if (
        isAuthenticated() &&
        resource.data.ownerId == request.auth.uid &&
        request.resource.data.ownerId == request.auth.uid &&
        request.resource.data.visibility in ['public', 'private']
      ) || isValidThemeInstallUpdate();

      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
    }

    // =============================================
    // REVIEWS RULES (for marketplace)
    // =============================================

    // Helper function to check if user can access content for review
    function canAccessContent(contentType, contentId) {
      return contentType == 'quiz' ? (
        get(/databases/$(database)/documents/quizzes/$(contentId)).data.visibility in ['public', 'unlisted']
      ) : contentType == 'deck' ? (
        get(/databases/$(database)/documents/flashcardDecks/$(contentId)).data.visibility in ['public', 'unlisted']
      ) : contentType == 'material' ? (
        get(/databases/$(database)/documents/learningMaterials/$(contentId)).data.visibility in ['public', 'unlisted']
      ) : contentType == 'theme' ? (
        get(/databases/$(database)/documents/themes/$(contentId)).data.visibility == 'public'
      ) : false;
    }

    // Helper function to check if user is content owner
    function isContentOwner(contentType, contentId) {
      return contentType == 'quiz' ? (
        get(/databases/$(database)/documents/quizzes/$(contentId)).data.ownerId == request.auth.uid
      ) : contentType == 'deck' ? (
        get(/databases/$(database)/documents/flashcardDecks/$(contentId)).data.ownerId == request.auth.uid
      ) : contentType == 'material' ? (
        get(/databases/$(database)/documents/learningMaterials/$(contentId)).data.ownerId == request.auth.uid
      ) : contentType == 'theme' ? (
        get(/databases/$(database)/documents/themes/$(contentId)).data.ownerId == request.auth.uid
      ) : false;
    }

    // Helper function to check if user is enrolled (participant) - without checking ownership
    function isParticipant(contentType, contentId) {
      return contentType == 'quiz' ?
        exists(/databases/$(database)/documents/quizParticipants/$(contentId)/participants/$(request.auth.uid))
      : contentType == 'deck' ?
        exists(/databases/$(database)/documents/deckParticipants/$(contentId)/participants/$(request.auth.uid))
      : contentType == 'material' ?
        exists(/databases/$(database)/documents/materialParticipants/$(contentId)/participants/$(request.auth.uid))
      : contentType == 'theme' ?
        true  // For themes, allow all authenticated users (can't check localStorage)
      : false;
    }

    // Reviews collection
    match /reviews/{reviewId} {
      // Anyone can read reviews for public/unlisted content
      allow read: if canAccessContent(resource.data.contentType, resource.data.contentId);

      // Authenticated users can create reviews ONLY if:
      // 1. User is a participant (enrolled in content)
      // 2. Rating is valid (1-5)
      // 3. User ID matches authenticated user
      // Note: Temporarily removed owner check for debugging
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       isParticipant(request.resource.data.contentType, request.resource.data.contentId) &&
                       request.resource.data.rating >= 1 &&
                       request.resource.data.rating <= 5;

      // Only review author can update their own review
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.rating >= 1 &&
                       request.resource.data.rating <= 5;

      // Review author or content owner can delete reviews
      allow delete: if isAuthenticated() &&
                       (resource.data.userId == request.auth.uid ||
                        isContentOwner(resource.data.contentType, resource.data.contentId));
    }

    // =============================================
    // CONFIG COLLECTION (for featured content, etc.)
    // =============================================

    // Config collection for app-wide settings (read-only for users)
    match /config/{configId} {
      allow read: if true;  // Anyone can read config (including featuredContent)
      allow write: if false;  // Only admin SDK can write (server-side)
    }
  }
}
